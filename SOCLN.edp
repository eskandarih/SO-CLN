include "./Geometry/Minduct1.idp"
int coil=Th(a1/2,c/2).region;
int york=Th(a1/2,3*b1/4).region;

 verbosity = 0;

int debugging = 1; //if you don't want the plots set this to 0
int FPmax = 50; // maximum number of Fixed Point iterations
int numStages = 5;
real [int] lambda(2*numStages+1);
real RR,LL;

real nu0=1e7/4/pi;
real nu1=1e3/4/pi;
real hn=10., h0=1.;
int nb=1;

ofstream gg("SOCLNresults.txt");
gg << "h1           |h3           | R0           | L1           | R2           | L3           | R4           | L5           | R6           | L7           | R8           | L9           |" << endl;
macro Curl(u) [dy(u),-dx(u)] //

fespace Vh(Th,P1);
Vh Az=0, dA, w;
Vh[int] Ac(numStages);
Vh[int] Ec(numStages+1);
Ac[0] = 0;
Ac[1] = 0;

fespace V0(Th,P1dc);
V0 Bx=0, By=0, Bm, E, nu, mu, nuNew, muNew, err;
V0 co=1.0*(region==coil);
V0 yo=1.0*(region==york);
V0 ar=1.0*(region!=york);
V0 sig = 4.0e7*co+1.0e6*yo;

E=1.0*co;
Ec[0] = E;
lambda[0] = int2d(Th)( sig*E^2 );
RR = 1./lambda[0];

nu=nu1*yo + nu0*ar;
mu = 1./nu;

problem MagCLN(Az,w,solver=CG) = int2d(Th)( nu*Curl(Az)'*Curl(w) ) -int2d(Th)( RR*sig*E*w ) +on(out4,Az=0)+on(out5,Az=0)+on(out6,Az=0)+on(out7,Az=0);

real vminh1=-3, vmaxh1=1, mmaxh1=4, h1; //sweeping the h1=I1 from 10^vmin to 10^vmax in mmax steps
real vminh3=-3, vmaxh3=1, mmaxh3=4, h3; //sweeping the h3=I1 from 10^vmin to 10^vmax in mmax steps

for (int h1idx=0; h1idx<=mmaxh1; h1idx++){
    h1 = 10^(vminh1 + (vmaxh1-vminh1)*h1idx/mmaxh1);

    for (int h3idx=0; h3idx<=mmaxh3; h3idx++){
        h3 = 10^(vminh3 + (vmaxh3-vminh3)*h3idx/mmaxh3);

        // updating permeability nu(h1,h3)
        Az = h1*Ac[0] + h3*Ac[1];
        Bx=dy(Az);
        By=-dx(Az);
        nu=(hn*(Bx^2+By^2)^nb+h0)*nu1*yo + nu0*ar;
        mu = 1./nu;

        // calculating nu(h1,h3) using fixed-point method
        for (int FPiter=1; FPiter<=FPmax; FPiter++){


            RR = 1./lambda[0];
            E = Ec[0];
            MagCLN;            
            Ac[0] = Az;
            lambda[1] = int2d(Th)( nu*(dx(Ac[0])^2+dy(Ac[0])^2) );
            LL = lambda[1];
            Ec[1] = Ec[0] - Ac[0]/LL;
            E = Ec[1];
            lambda[1] = int2d(Th)( sig*E^2 );
            RR = 1./lambda[1];
            MagCLN;
            Ac[1] = Az;

            // updating permeability nu(h1,h3)
            Az = h1*Ac[0] + h3*Ac[1];
            Bx=dy(Az);
            By=-dx(Az);
            nuNew = (hn*(Bx^2+By^2)^nb+h0)*nu1*yo + nu0*ar;
            muNew = 1./nuNew;

            err = mu-muNew;
            real magMu = mu[].l2;
            real bflag = err[].l2 / magMu;

            nu = nuNew;
            mu = 1./nu;

            cout << "h1=" << h1 <<"  h3="<< h3 <<"   FPiter="<<FPiter<<"    bflag="<<bflag <<"   magMu="<<magMu << endl;

            if (bflag < 1e-5) {
                cout << "============================================" << endl;
                break;
            }

        }
    }
}

